/*
参考：https://zhuanlan.zhihu.com/p/74436158
定义递归函数 f(n，m) 的返回结果是存活士兵的编号，显然当 n = 1 时，f(n, m) = 1。假如我们能够找出 f(n，m) 和 f(n-1，m) 之间的关系的话，
我们就可以用递归的方式来解决了。我们假设人员数为 n, 报数到 m 的人就自杀。则刚开始的编号为… 1 ... m - 2m - 1mm + 1m + 2 ... n …进行了
一次删除之后，删除了编号为 m 的节点。删除之后，就只剩下 n - 1 个节点了，删除前和删除之后的编号转换关系为：
删除前     ---     删除后…          ---      …m - 2     ---     n - 2m - 1    ---      n - 1m         ----    
无(因为编号被删除了)m + 1     ---     1(因为下次就从这里报数了)m + 2     ----     2…         ----         …新的环中只有 n - 1 个节点。
且删除前编号为 m + 1, m + 2, m + 3 的节点成了删除后编号为 1， 2， 3 的节点。假设 old 为删除之前的节点编号， new 为删除了一个节点之后的编号，
则 old 与 new 之间的关系为 old = (new + m - 1) % n + 1。 注：有些人可能会疑惑为什么不是 old = (new + m ) % n 呢？主要是因为编号是从 1 开
始的，而不是从 0 开始的。如果 new + m == n的话，会导致最后的计算结果为 old = 0。所以 old = (new + m - 1) % n + 1. 这样，我们就得出 f(n, m)
与 f(n - 1, m)之间的关系了，而 f(1, m) = 1.所以我们可以采用递归的方式来做。代码如下：
int f(int n, int m){
    if(n == 1)   return n;
    return (f(n - 1, m) + m - 1) % n + 1;
}我去，两行代码搞定，而且时间复杂度是 O(n)，空间复杂度是O(n)，牛逼！那如果你想跟别人说，我想一行代码解决约瑟夫问题呢？答是没问题的，如下：int f(int n, int m){
    return n == 1 ? n : (f(n - 1, m) + m - 1) % n + 1;
}
*/
class Solution {

    public int f(int n, int m) {
        return n==1 ? 1 : (f(n-1, m) + m - 1) % n + 1;
    }

    public int lastRemaining(int n, int m) {
        return f(n, m) - 1;
    }
}
